/*
* Cupket.js
*
* An open source class for interacting with websocket servers
*
*
* @package Cupket.js < Cuppy Sockets >
*
* @author Frost  Codes( Oluwaseyi Aderinkomi )
*
* @license    http://www.dbad-license.org/  DON'T BE A DICK PUBLIC LICENSE
*
* @author     Frost  Codes( Oluwaseyi Aderinkomi ) <seyiaderinkomi@gmail.com>
*
* @version 1.1
*
* ----------- LICENSE ----------
*
*
*  # DON'T BE A DICK PUBLIC LICENSE
*  
*  > Version 1.1, MAY 2018
*  
*  > Copyright (C) 2018 Punchline Technologies
*  
*  Everyone is permitted to copy and distribute verbatim or modified
*  copies of this license document.
*  
*  > DON'T BE A DICK PUBLIC LICENSE
*  > TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
*  
*  1. Do whatever you like with the original work, just don't be a dick.
*  
*  Being a dick includes - but is not limited to - the following instances:
*  
*   1a. Outright copyright infringement - Don't just copy this and change the name.
*   1b. Selling the unmodified original with no work done what-so-ever, that's REALLY being a dick.
*  1c. Modifying the original work to contain hidden harmful content. That would make you a PROPER dick.
*
*  2. If you become rich through modifications, related works/services, or supporting the original work,
*  share the love. Only a dick would make loads off this work and not buy the original work's
*  creator(s) a pint.
*  
*  3. Code is provided with no warranty. Using somebody else's code and bitching when it goes wrong makes
*  you a DONKEY dick. Fix the problem yourself. A non-dick would submit the fix back.
*    
*  
*  
*/

class cupket{constructor(server='localhost',protocols,options){let self=this;var settings={secured:!1,port:9060,id:Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15),autoReconnect:!0,reconnectInterval:2500,allowDebug:!1,TimeLogging:!1,}
if(!options){options={}}
for(var key in settings){if(typeof options[key]!=='undefined'){this[key]=options[key]}else{this[key]=settings[key]}}
this.connString='';this.protocols=protocols;this.connectionStates={CONNECTING:0,OPEN:1,CLOSING:2,CLOSED:3};this.statistics={};this.statistics.totalPacketSent=0;this.statistics.totalFailedRequests=0;this.statistics.totalDataRequests=0;this.statistics.totalPacketReceived=0;this.statistics.totalDataReceived=0;this.statistics.totalReconnects=0;try{if(!window.WebSocket){window.WebSocket=window.MozWebSocket}
console.log('Started Cupket Sockets!');console.log('Initial Cupket Sockets ID: '+this.id);if(!this.isSupported()){console.warn('Cupket cant run... The current browser does not support web sockets!');console.log('Setting Cupket Object to undefined!');self=undefined;return undefined}
else{if(this.secured){this.connString='wss://'+server+':'+this.port}
else{this.connString='ws://'+server+':'+this.port}
this.ws=new WebSocket(this.connString,this.protocols||[]);if(this.allowDebug){console.log('Debugging is active...');console.log('Connecting to server !');console.log('Connecting using configs: {  '+this.connString+'  } and current cupket id is: '+this.id);if(this.protocols){console.log('Protocols used for connection :');console.log(this.protocols)}}
this.ws.onopen=function(evt){if(self.allowDebug){console.log('Cupket was able to open connection @ '+new Date());console.log(evt)}
self.cupket_event('cupket_onopen',evt)};this.ws.onmessage=function(evt){if(self.allowDebug){console.log('Message packets received @ '+new Date());console.log(evt)}
self.statistics.totalDataReceived++;self.__updateTotalPacketReceived(evt.data);self.cupket_event('cupket_onmessage',evt)};this.ws.onclose=function(evt){if(self.isTimeLogging){console.warn('Cupket sockets disconnected from server @ '+new Date())}
if(self.allowDebug){console.log('Connection Closed: ');console.log('Code: '+evt.code+'    Type: '+evt.type);console.log('Extra data...');console.log(evt)}
if(self.isAutoReconnect()){self.reconnect()}
self.cupket_event('cupket_onclose',evt)};this.ws.onerror=function(evt){if(self.isTimeLogging){console.warn('Cupket sockets encountered an error @ '+new Date())}
if(self.allowDebug){console.warn('Error Occured '+evt.data);console.log('Extra info...');console.log(evt)}
self.cupket_event('cupket_onerror',evt)}}}
catch(err){console.log(err.message);return!1}}
cupket(){return this.ws}
connectionString(){return this.connString}
isAutoReconnect(){return this.autoReconnect}
enableAutoReconnect(){this.autoReconnect=!0}
disableAutoReconnect(){this.autoReconnect=!1}
isDebugging(){return this.allowDebug}
enableDebugging(){this.allowDebug=!0}
disableDebugging(){this.allowDebug=!1}
isTimeLogging(){return this.TimeLogging}
enableTimeLogging(){this.TimeLogging=!0}
disableTimeLogging(){this.TimeLogging=!1}
cupket_event(type,data){try{window[type](this.id,data)}
catch(err){console.warn('There is no available handler for [  '+type+'  ]. Events would not be handled. Please consider adding one!');if(this.isDebugging()){console.log('There is no Event handler for [  '+type+'  ], current Cupket id is : '+this.id)}}}
isConnected(){return(this.cupket().readyState===this.connectionStates.OPEN)}
connectionState(){return cupket.readyState}
isConnectionState(connectionState){return(this.isConnected()==connectionState)}
reconnect(){if(this.isConnected()){this.close();this.ws=null}
var self=this;var tryReconnect=setInterval(function(){if(!self.isConnected()){self.ws=new WebSocket(self.connString,self.protocols||[]);if(self.isDebugging()){console.log('Cupket is trying to reconnect to server ... @ '+new
Date())}
self.statistics.totalReconnects ++}
else{if(self.isDebugging()){console.log('Cupket was able to reconnect to server ... @ '+new
Date())}
self.cupket_event('cupket_onreconnected',self);clearInterval(tryReconnect)}},this.reconnectInterval)}
close(stopReconnect=!1){if(this.isDebugging()){console.log('Cupket sockets closed by user @ '+new Date())}
this.cupket().close();if(stopReconnect){this.disableAutoReconnect()}}
isSupported(){if(window.WebSocket){if(this.isDebugging()){console.log('Browser supports Web Sockets...')}
return!0}
else{if(this.isDebugging()){console.log('Browser does not support Web Sockets...')}
return!1}}
resetStatistics(){if(this.isTimeLogging){console.log('Cupket sockets data statistics was reseted @ '+new Date())}
if(this.isDebugging()){console.log('Cupket sockets data statistics reseted !')}
this.statistics.totalPacketSent=0;this.statistics.totalFailedRequests=0;this.statistics.totalDataRequests=0;this.statistics.totalPacketReceived=0;this.statistics.totalDataReceived=0}
__updateTotalPacketSent(data){var isBlob=data instanceof Blob;var isArrayBuffer=data instanceof ArrayBuffer;if(isBlob&&!isArrayBuffer){this.statistics.totalPacketSent=data.size+this.statistics.totalPacketSent}
else if(isArrayBuffer){this.statistics.totalPacketSent=data.byteLength+this.statistics.totalPacketSent}
else{this.statistics.totalPacketSent=this.byteLengthOf(String(data))+this.statistics.totalPacketSent}}
__updateTotalPacketReceived(data){var isBlob=data instanceof Blob;var isArrayBuffer=data instanceof ArrayBuffer;if(isBlob&&!isArrayBuffer){this.statistics.totalPacketReceived=data.size+this.statistics.totalPacketReceived}
else if(isArrayBuffer){this.statistics.totalPacketReceived=data.byteLength+this.statistics.totalPacketReceived}
else{this.statistics.totalPacketReceived=this.byteLengthOf(String(data))+this.statistics.totalPacketReceived}}
send(data=''){this.statistics.totalDataRequests++;this.cupket_event('cupket_onsend',data);if(this.TimeLogging){console.log('Message packets scheduled to be sent @ '+new Date())}
try{if(!this.isConnected()){console.log('Cupket is not connected to server!');this.statistics.totalFailedRequests++;return!1}
else{this.ws.send(data);this.__updateTotalPacketSent(data);return!0}}
catch(err){console.log(err.message);if(this.isDebugging()){if(!this.isConnected()){console.log('Cupket is not connected to server!')}}
return!1}}
_generateCustomDataFormat(data,separator=';'){var Content='';var dataString='';data.forEach(function(infoArray,index){dataString=infoArray.join(separator);Content+=index<data.length?dataString+'\n':dataString});this.cupket().binaryType='blob';return Content}
sendCSV(data){return this.send(this._generateCustomDataFormat(data))}
sendTSV(data){return this.send(this._generateCustomDataFormat(data,'	'))}
sendCustomSeperatedData(data,seperator){return this.send(this._generateCustomDataFormat(data,seperator))}
sendJSON(data){this.cupket().binaryType='blob';return this.send(JSON.stringify(data))}
getArrayBytes(data){var bytes=[];for(var i=0;i<data.length;i++){bytes.push(data.charCodeAt(i))}
return bytes}
sendArrayBuffer(data){var array=new Uint8Array(this.getArrayBytes(data));this.cupket().binaryType='arraybuffer';if(this.isDebugging()){console.log('Sending data as Array Buffer, buffer data:  ');console.log(array.buffer);console.log('Full array object data: ');console.log(array)}
return this.send(array.buffer)}
getByteArray(data){var byteArray=[];for(var i=0;i<data.length;++i){byteArray.push(data.charCodeAt(i)&0xff)}
return byteArray}
ascii_to_hexa(str)
{var arr1=[];for(var n=0,l=str.length;n<l;n ++)
{var hex=Number(str.charCodeAt(n)).toString(16);arr1.push(hex)}
return arr1.join('')}
sendByteBuffer(data){var buffer=this.ascii_to_hexa(data);this.cupket().binaryType='bytebuffer';if(this.isDebugging()){console.log('Sending data as Byte Buffer, buffer data:  ');console.log(buffer)}
return this.send(buffer)}
sendBlob(data,type='text/plain'){var options={};options.type=type;var blob=new Blob(data,options);this.cupket().binaryType='blob';if(this.isDebugging()){console.log('Sending data as Blob, MIME type: '+type+' , Blob data:  ');console.log(blob)}
return this.send(blob)}
byteLengthOf(s){var n=0;for(var i=0,l=s.length;i<l;i++){var hi=s.charCodeAt(i);if(hi<0x0080){n+=1}else if(hi<0x0800){n+=2}else if(hi<0xD800){n+=3}else if(hi<0xDC00){var lo=s.charCodeAt(++i);if(i<l&&lo>=0xDC00&&lo<=0xDFFF){n+=4}else{throw new Error("UCS-2 String malformed")}}else if(hi<0xE000){throw new Error("UCS-2 String malformed")}else{n+=3}}
return n}}